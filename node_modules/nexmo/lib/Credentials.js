"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _JwtGenerator = require('./JwtGenerator');

var _JwtGenerator2 = _interopRequireDefault(_JwtGenerator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Right now only key/secret credentials are supported.
 * However, in time JWT will also be supported.
 * The `Credentials` object provides an abstraction to this.
 *
 * @param {string} apiKey - A Nexmo API Key
 * @param {string} apiSecret - A Nexmo API Secret
 * @param {string|Buffer} [privateKey] -  When a string value is passed it should
 *                        either represent the path to the private key, or the actual
 *                        private key in string format. If a Buffer is passed then
 *                        it should be the key read from the file system.
 */

var Credentials = function () {
  function Credentials(apiKey, apiSecret, privateKey, applicationId) {
    _classCallCheck(this, Credentials);

    this.apiKey = apiKey;
    this.apiSecret = apiSecret;

    this.privateKey = null;
    this.applicationId = applicationId;

    if (privateKey instanceof Buffer) {
      this.privateKey = privateKey;
    } else if (privateKey instanceof String && privateKey.startsWith('-----BEGIN PRIVATE KEY-----')) {
      this.privateKey = new Buffer(privateKey);
    } else if (privateKey !== undefined) {
      if (!_fs2.default.existsSync(privateKey)) {
        throw new Error('File "' + privateKey + '" not found.');
      }
      this.privateKey = _fs2.default.readFileSync(privateKey);
    }

    /** @private */
    this._jwtGenerator = new _JwtGenerator2.default();
  }

  /**
   * Generate a Jwt using the Private Key in the Credentials.
   * By default the credentials.applicationId will be used when creating the token.
   * However, this can be overwritten.
   *
   * @param {string} [applicationId] an application ID to be used instead of the
   *                default Credentials.applicationId value.
   *
   * @returns {string} The generated JWT
   */


  _createClass(Credentials, [{
    key: 'generateJwt',
    value: function generateJwt() {
      var applicationId = arguments.length <= 0 || arguments[0] === undefined ? this.applicationId : arguments[0];
      var privateKey = arguments.length <= 1 || arguments[1] === undefined ? this.privateKey : arguments[1];

      var claims = { application_id: applicationId };
      var token = this._jwtGenerator.generate(privateKey, claims);
      return token;
    }

    /**
     * @private
     * Used for testing purposes only.
     */

  }, {
    key: '_setJwtGenerator',
    value: function _setJwtGenerator(generator) {
      this._jwtGenerator = generator;
    }

    /**
     * Ensures a credentials instance is used.
     *
     * Key/Secret credentials are only supported at present.
     */

  }], [{
    key: 'parse',
    value: function parse(obj) {
      if (obj instanceof Credentials) {
        return obj;
      } else {
        return new Credentials(obj.apiKey, obj.apiSecret, obj.privateKey, obj.applicationId);
      }
    }
  }]);

  return Credentials;
}();

exports.default = Credentials;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9DcmVkZW50aWFscy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7QUFFQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFjTSxXO0FBQ0osdUJBQVksTUFBWixFQUFvQixTQUFwQixFQUErQixVQUEvQixFQUEyQyxhQUEzQyxFQUEwRDtBQUFBOztBQUN4RCxTQUFLLE1BQUwsR0FBYyxNQUFkO0FBQ0EsU0FBSyxTQUFMLEdBQWlCLFNBQWpCOztBQUVBLFNBQUssVUFBTCxHQUFrQixJQUFsQjtBQUNBLFNBQUssYUFBTCxHQUFxQixhQUFyQjs7QUFFQSxRQUFHLHNCQUFzQixNQUF6QixFQUFpQztBQUMvQixXQUFLLFVBQUwsR0FBa0IsVUFBbEI7QUFDRCxLQUZELE1BR0ssSUFBRyxzQkFBc0IsTUFBdEIsSUFDTCxXQUFXLFVBQVgsQ0FBc0IsNkJBQXRCLENBREUsRUFDb0Q7QUFDdkQsV0FBSyxVQUFMLEdBQWtCLElBQUksTUFBSixDQUFXLFVBQVgsQ0FBbEI7QUFDRCxLQUhJLE1BSUEsSUFBRyxlQUFlLFNBQWxCLEVBQTZCO0FBQ2hDLFVBQUcsQ0FBQyxhQUFHLFVBQUgsQ0FBYyxVQUFkLENBQUosRUFBK0I7QUFDN0IsY0FBTSxJQUFJLEtBQUosWUFBbUIsVUFBbkIsa0JBQU47QUFDRDtBQUNELFdBQUssVUFBTCxHQUFrQixhQUFHLFlBQUgsQ0FBZ0IsVUFBaEIsQ0FBbEI7QUFDRDs7O0FBR0QsU0FBSyxhQUFMLEdBQXFCLDRCQUFyQjtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7O2tDQVk2RTtBQUFBLFVBQWxFLGFBQWtFLHlEQUFsRCxLQUFLLGFBQTZDO0FBQUEsVUFBOUIsVUFBOEIseURBQWpCLEtBQUssVUFBWTs7QUFDNUUsVUFBSSxTQUFTLEVBQUMsZ0JBQWdCLGFBQWpCLEVBQWI7QUFDQSxVQUFJLFFBQVEsS0FBSyxhQUFMLENBQW1CLFFBQW5CLENBQTRCLFVBQTVCLEVBQXdDLE1BQXhDLENBQVo7QUFDQSxhQUFPLEtBQVA7QUFDRDs7Ozs7Ozs7O3FDQU1nQixTLEVBQVc7QUFDMUIsV0FBSyxhQUFMLEdBQXFCLFNBQXJCO0FBQ0Q7Ozs7Ozs7Ozs7MEJBT1ksRyxFQUFLO0FBQ2hCLFVBQUcsZUFBZSxXQUFsQixFQUErQjtBQUM3QixlQUFPLEdBQVA7QUFDRCxPQUZELE1BR0s7QUFDSCxlQUFPLElBQUksV0FBSixDQUFnQixJQUFJLE1BQXBCLEVBQTRCLElBQUksU0FBaEMsRUFBMkMsSUFBSSxVQUEvQyxFQUEyRCxJQUFJLGFBQS9ELENBQVA7QUFDRDtBQUNGOzs7Ozs7a0JBR1ksVyIsImZpbGUiOiJDcmVkZW50aWFscy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IEp3dEdlbmVyYXRvciBmcm9tICcuL0p3dEdlbmVyYXRvcic7XG5cbi8qKlxuICogUmlnaHQgbm93IG9ubHkga2V5L3NlY3JldCBjcmVkZW50aWFscyBhcmUgc3VwcG9ydGVkLlxuICogSG93ZXZlciwgaW4gdGltZSBKV1Qgd2lsbCBhbHNvIGJlIHN1cHBvcnRlZC5cbiAqIFRoZSBgQ3JlZGVudGlhbHNgIG9iamVjdCBwcm92aWRlcyBhbiBhYnN0cmFjdGlvbiB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcGlLZXkgLSBBIE5leG1vIEFQSSBLZXlcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcGlTZWNyZXQgLSBBIE5leG1vIEFQSSBTZWNyZXRcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gW3ByaXZhdGVLZXldIC0gIFdoZW4gYSBzdHJpbmcgdmFsdWUgaXMgcGFzc2VkIGl0IHNob3VsZFxuICogICAgICAgICAgICAgICAgICAgICAgICBlaXRoZXIgcmVwcmVzZW50IHRoZSBwYXRoIHRvIHRoZSBwcml2YXRlIGtleSwgb3IgdGhlIGFjdHVhbFxuICogICAgICAgICAgICAgICAgICAgICAgICBwcml2YXRlIGtleSBpbiBzdHJpbmcgZm9ybWF0LiBJZiBhIEJ1ZmZlciBpcyBwYXNzZWQgdGhlblxuICogICAgICAgICAgICAgICAgICAgICAgICBpdCBzaG91bGQgYmUgdGhlIGtleSByZWFkIGZyb20gdGhlIGZpbGUgc3lzdGVtLlxuICovXG5jbGFzcyBDcmVkZW50aWFscyB7XG4gIGNvbnN0cnVjdG9yKGFwaUtleSwgYXBpU2VjcmV0LCBwcml2YXRlS2V5LCBhcHBsaWNhdGlvbklkKSB7XG4gICAgdGhpcy5hcGlLZXkgPSBhcGlLZXk7XG4gICAgdGhpcy5hcGlTZWNyZXQgPSBhcGlTZWNyZXQ7XG5cbiAgICB0aGlzLnByaXZhdGVLZXkgPSBudWxsO1xuICAgIHRoaXMuYXBwbGljYXRpb25JZCA9IGFwcGxpY2F0aW9uSWQ7XG5cbiAgICBpZihwcml2YXRlS2V5IGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICB0aGlzLnByaXZhdGVLZXkgPSBwcml2YXRlS2V5O1xuICAgIH1cbiAgICBlbHNlIGlmKHByaXZhdGVLZXkgaW5zdGFuY2VvZiBTdHJpbmcgJiZcbiAgICAgICBwcml2YXRlS2V5LnN0YXJ0c1dpdGgoJy0tLS0tQkVHSU4gUFJJVkFURSBLRVktLS0tLScpKSB7XG4gICAgICB0aGlzLnByaXZhdGVLZXkgPSBuZXcgQnVmZmVyKHByaXZhdGVLZXkpO1xuICAgIH1cbiAgICBlbHNlIGlmKHByaXZhdGVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYoIWZzLmV4aXN0c1N5bmMocHJpdmF0ZUtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWxlIFwiJHtwcml2YXRlS2V5fVwiIG5vdCBmb3VuZC5gKVxuICAgICAgfVxuICAgICAgdGhpcy5wcml2YXRlS2V5ID0gZnMucmVhZEZpbGVTeW5jKHByaXZhdGVLZXkpO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuX2p3dEdlbmVyYXRvciA9IG5ldyBKd3RHZW5lcmF0b3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIEp3dCB1c2luZyB0aGUgUHJpdmF0ZSBLZXkgaW4gdGhlIENyZWRlbnRpYWxzLlxuICAgKiBCeSBkZWZhdWx0IHRoZSBjcmVkZW50aWFscy5hcHBsaWNhdGlvbklkIHdpbGwgYmUgdXNlZCB3aGVuIGNyZWF0aW5nIHRoZSB0b2tlbi5cbiAgICogSG93ZXZlciwgdGhpcyBjYW4gYmUgb3ZlcndyaXR0ZW4uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbYXBwbGljYXRpb25JZF0gYW4gYXBwbGljYXRpb24gSUQgdG8gYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICBkZWZhdWx0IENyZWRlbnRpYWxzLmFwcGxpY2F0aW9uSWQgdmFsdWUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBnZW5lcmF0ZWQgSldUXG4gICAqL1xuICBnZW5lcmF0ZUp3dChhcHBsaWNhdGlvbklkID0gdGhpcy5hcHBsaWNhdGlvbklkLCBwcml2YXRlS2V5ID0gdGhpcy5wcml2YXRlS2V5KSB7XG4gICAgdmFyIGNsYWltcyA9IHthcHBsaWNhdGlvbl9pZDogYXBwbGljYXRpb25JZH07XG4gICAgdmFyIHRva2VuID0gdGhpcy5fand0R2VuZXJhdG9yLmdlbmVyYXRlKHByaXZhdGVLZXksIGNsYWltcyk7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFVzZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cbiAgICovXG4gIF9zZXRKd3RHZW5lcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgdGhpcy5fand0R2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuc3VyZXMgYSBjcmVkZW50aWFscyBpbnN0YW5jZSBpcyB1c2VkLlxuICAgKlxuICAgKiBLZXkvU2VjcmV0IGNyZWRlbnRpYWxzIGFyZSBvbmx5IHN1cHBvcnRlZCBhdCBwcmVzZW50LlxuICAgKi9cbiAgc3RhdGljIHBhcnNlKG9iaikge1xuICAgIGlmKG9iaiBpbnN0YW5jZW9mIENyZWRlbnRpYWxzKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgQ3JlZGVudGlhbHMob2JqLmFwaUtleSwgb2JqLmFwaVNlY3JldCwgb2JqLnByaXZhdGVLZXksIG9iai5hcHBsaWNhdGlvbklkKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ3JlZGVudGlhbHM7XG4iXX0=